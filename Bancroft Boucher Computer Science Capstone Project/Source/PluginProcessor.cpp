/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "StereoWidthCtrl2.h"
#include "juce_Reverb.h"
#include "SimpleGain.h"



//==============================================================================
StereoWidthCtrl2AudioProcessor::StereoWidthCtrl2AudioProcessor()
{
    
    UserParams[StereoBypass]=0.0f;//default to not bypassed
    UserParams[StereoWidth]=1.0f;//default Width 1.0 (no change)
    UserParams[Roomsize]= 0.5f;
    UserParams[Damping]= 0.5f;
    UserParams[Wetlevel]= 0.0f;
    UserParams[Drylevel]= 0.4f;
    UserParams[Reverbwidth]= 1.0f;
    UserParams[Freezemode]= 0.0f;
    UserParams[threshold]= 100.0f;
    UserParams[ratio]= 0.0f;
    UserParams[ReverbBypass]=0.0f;
    UserParams[CompressorBypass]=0.0f;
    mWidthControl.SetWidth(UserParams[StereoWidth]);//push VST default to effect
    
    /*newparameter.roomSize=UserParams[Roomsize];
    newparameter.damping=UserParams[Damping];
    newparameter.wetLevel=UserParams[Wetlevel];
    newparameter.dryLevel=UserParams[Drylevel];
    newparameter.width=UserParams[Reverbwidth];
    newparameter.freezeMode=UserParams[Freezemode];
    areverb.setParameters(newparameter);*/
    
    
    
    
    
    
    UIUpdateFlag=true;//Request UI update
}

StereoWidthCtrl2AudioProcessor::~StereoWidthCtrl2AudioProcessor()
{
}

//==============================================================================
const String StereoWidthCtrl2AudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int StereoWidthCtrl2AudioProcessor::getNumParameters()
{
    return totalNumParam;
}

float StereoWidthCtrl2AudioProcessor::getParameter (int index)
{
    switch(index)
    {
        case StereoBypass:
            return UserParams[StereoBypass];
            
        case StereoWidth:
            UserParams[StereoWidth] =mWidthControl.Getwidth();
            return UserParams[StereoWidth];
        case Roomsize:
            newparameter=areverb.getParameters();
            return newparameter.roomSize;
        case Damping:
            newparameter=areverb.getParameters();
            return newparameter.damping;
        case Wetlevel:
            newparameter=areverb.getParameters();
            return newparameter.wetLevel;
        case Drylevel:
            newparameter=areverb.getParameters();
            return newparameter.dryLevel;
        case Reverbwidth:
            newparameter=areverb.getParameters();
            return newparameter.width;
        case Freezemode:
            newparameter=areverb.getParameters();
            return newparameter.freezeMode;
        case threshold:
            return UserParams[threshold];
            
        case ratio:
            return UserParams[ratio];
            
        case ReverbBypass:
            return UserParams[ReverbBypass];
            
        case CompressorBypass:
            return UserParams[CompressorBypass];
            
        default: return 0.0f;//invalid index
    }
}

void StereoWidthCtrl2AudioProcessor::setParameter (int index, float newValue)
{
    switch(index)
    {
        case StereoBypass:
            UserParams[StereoBypass]=newValue;
            break;
        case StereoWidth:
            UserParams[StereoWidth]=newValue;
            mWidthControl.SetWidth(UserParams[StereoWidth]);
            break;
        case Roomsize:
            UserParams[Roomsize]=newValue;
            newparameter.roomSize=UserParams[Roomsize];
            areverb.setParameters(newparameter);
            break;
        case Damping:
            UserParams[Damping]=newValue;
            newparameter.damping=UserParams[Damping];
            areverb.setParameters(newparameter);
            break;
        case Wetlevel:
            UserParams[Wetlevel]=newValue;
            newparameter.wetLevel=UserParams[Wetlevel];
            areverb.setParameters(newparameter);
            break;
        case Drylevel:
            UserParams[Drylevel]=newValue;
            newparameter.dryLevel=UserParams[Drylevel];
            areverb.setParameters(newparameter);
            break;
        case Reverbwidth:
            UserParams[Reverbwidth]=newValue;
            newparameter.width=UserParams[Reverbwidth];
            areverb.setParameters(newparameter);
            break;
        case Freezemode:
            UserParams[Freezemode]=newValue;
            newparameter.freezeMode=UserParams[Freezemode];
            areverb.setParameters(newparameter);
            break;
        case threshold:
            UserParams[threshold]=newValue;
            break;
        case ratio:
            UserParams[ratio]=newValue;
            break;
        case ReverbBypass:
            UserParams[ReverbBypass]=newValue;
            break;
        case CompressorBypass:
            UserParams[CompressorBypass]=newValue;
            break;
        default: return;
    }
    UIUpdateFlag=true;//Request UI update -- Some OSX hosts use alternate editors, this updates ours
}

const String StereoWidthCtrl2AudioProcessor::getParameterName (int index)
{
    switch(index)
    {
        case StereoBypass:
            return "Stereo Bypass";
            
        case StereoWidth:
            return "Stereowidth Factor";
        case Roomsize:
            return "Room Size";
        case Damping:
            return "Damping";
        case Wetlevel:
            return "Wet Level";
        case Drylevel:
            return "Dry Level";
        case Reverbwidth:
           return "Reverb Width";
        case Freezemode:
            return "Freeze Mode";
        case threshold:
            return "Threshold";
            
        case ratio:
            return "Ratio";
            
        case ReverbBypass:
            return "Reverb Bypass";
            
        case CompressorBypass:
            return "Compressor Bypass";
            
        default:return String::empty;
    }
}

const String StereoWidthCtrl2AudioProcessor::getParameterText (int index)
{
    if(index>=0 && index<totalNumParam)
        return String(UserParams[index]);//return parameter value as string
    else return String::empty;
}

const String StereoWidthCtrl2AudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String StereoWidthCtrl2AudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool StereoWidthCtrl2AudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool StereoWidthCtrl2AudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool StereoWidthCtrl2AudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool StereoWidthCtrl2AudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool StereoWidthCtrl2AudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double StereoWidthCtrl2AudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int StereoWidthCtrl2AudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int StereoWidthCtrl2AudioProcessor::getCurrentProgram()
{
    return 0;
}

void StereoWidthCtrl2AudioProcessor::setCurrentProgram (int index)
{
}

const String StereoWidthCtrl2AudioProcessor::getProgramName (int index)
{
    return String();
}

void StereoWidthCtrl2AudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void StereoWidthCtrl2AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void StereoWidthCtrl2AudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void StereoWidthCtrl2AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    float insq1, insq2, sum, rms, keydB, overdB, gr;
    const float DC_OFFSET = 1.0E-25;
    float ms_= 1.0;
    float sampleRate_ = 44100.0;
    float coef_=exp( -1000.0 / ( ms_ * sampleRate_ ) );
    float aveOfSqrs_ = DC_OFFSET;
    float envdB_ = DC_OFFSET;
    float* leftData = buffer.getWritePointer(0);
    float* rightData = buffer.getWritePointer(1);
    //float *samples0 = buffer.getWritePointer(0);
    //float *samples1 = buffer.getWritePointer(1);
    if(getNumInputChannels()<2)
	{
    }/*Nothing to do here - processing is in-place, so doing nothing is pass-through (for NumInputs=NumOutputs)*/
	//Not bypassed - do processing!
		
    if (!UserParams[StereoBypass]){
            for(long i=0; i<buffer.getNumSamples();i++){
            mWidthControl.ClockProcess(&leftData[i], &rightData[i]);
            
        }
    }
    if (!UserParams[ReverbBypass]){
        areverb.processStereo(leftData, rightData, buffer.getNumSamples());
        }
    if (!UserParams[CompressorBypass]){
            int numsamples= buffer.getNumSamples();
            while (numsamples>0){
                //*samples0++;
                //*samples1++;
                //numsamples--;
                insq1= *leftData * *leftData;
                insq2= *rightData * *rightData;
                sum = insq1 + insq2;
                sum += DC_OFFSET;
                aveOfSqrs_= sum+ coef_ *(aveOfSqrs_ - sum);
                rms= sqrt(aveOfSqrs_);
                rms=fabs(rms);
                rms += DC_OFFSET;
                keydB= log(rms)*8.6858896380650365530225783783321;
                keydB= fabs(keydB);
                overdB = keydB - UserParams[threshold];
                if (overdB< 0){
                    overdB = 0.0;
                }
                overdB += DC_OFFSET;
                if (overdB > envdB_){
                    envdB_= overdB + coef_ * (envdB_ - overdB);
                }
                else{
                    envdB_ = overdB + coef_ * ( envdB_ - overdB );
                }
                overdB = envdB_ - DC_OFFSET;
                gr= overdB *(UserParams[ratio] -1.0);
                gr= exp( gr * 0.11512925464970228420089957273422);
                //gr= UserParams[ratio_]/10;
                
                *leftData++ *= gr;
                *rightData++ *= gr;
                
                numsamples--;
                
        }
    }
        
    }
        /*else if (!UserParams[ReverbBypass])
        {
        areverb.processStereo(leftData, rightData, buffer.getNumSamples());
        }
        else if (!UserParams[CompressorBypass]){
        int numsamples= buffer.getNumSamples();
        while (numsamples>0){
            //*samples0++;
            //*samples1++;
            //numsamples--;
            insq1= *samples0 * *samples0;
            insq2= *samples1 * *samples1;
            sum = insq1 + insq2;
            sum += DC_OFFSET;
            aveOfSqrs_= sum+ coef_ *(aveOfSqrs_ - sum);
            rms= sqrt(aveOfSqrs_);
            rms=fabs(rms);
            rms += DC_OFFSET;
            keydB= log(rms)*8.6858896380650365530225783783321;
            keydB= fabs(keydB);
            overdB = keydB - UserParams[threshold];
            if (overdB< 0){
                overdB = 0.0;
            }
            overdB += DC_OFFSET;
            if (overdB > envdB_){
                envdB_= overdB + coef_ * (envdB_ - overdB);
            }
            else{
                envdB_ = overdB + coef_ * ( envdB_ - overdB );
            }
            overdB = envdB_ - DC_OFFSET;
            gr= overdB *(UserParams[ratio] -1.0);
            gr= exp( gr * 0.11512925464970228420089957273422);
            //gr= UserParams[ratio_]/10;
            
            *samples0++ *= gr;
            *samples1++ *= gr;
           
            numsamples--;
            
        }
        }
        else{
            
        }*/
        

    
    


//==============================================================================
bool StereoWidthCtrl2AudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* StereoWidthCtrl2AudioProcessor::createEditor()
{
    return new StereoWidthCtrl2AudioProcessorEditor (*this);
}

//==============================================================================
void StereoWidthCtrl2AudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    XmlElement root("Root");
    XmlElement *el;
    el = root.createNewChildElement("StereoBypass");
    el->addTextElement(String(UserParams[StereoBypass]));
    el = root.createNewChildElement("StereoWidth");
    el->addTextElement(String(UserParams[StereoWidth]));
    copyXmlToBinary(root,destData);
    el = root.createNewChildElement("RoomSize");
    el->addTextElement(String(UserParams[Roomsize]));
    copyXmlToBinary(root,destData);
    el = root.createNewChildElement("Damping");
    el->addTextElement(String(UserParams[Damping]));
    copyXmlToBinary(root,destData);
    el = root.createNewChildElement("Wetlevel");
    el->addTextElement(String(UserParams[Wetlevel]));
    copyXmlToBinary(root,destData);
    el = root.createNewChildElement("Drylevel");
    el->addTextElement(String(UserParams[Drylevel]));
    copyXmlToBinary(root,destData);
    el = root.createNewChildElement("ReverbWidth");
    el->addTextElement(String(UserParams[Reverbwidth]));
    copyXmlToBinary(root,destData);
    el = root.createNewChildElement("FreezeMode");
    el->addTextElement(String(UserParams[Freezemode]));
    copyXmlToBinary(root,destData);
    el = root.createNewChildElement("Threshold");
    el->addTextElement(String(UserParams[threshold]));
    copyXmlToBinary(root,destData);
    el = root.createNewChildElement("Ratio");
    el->addTextElement(String(UserParams[ratio]));
    copyXmlToBinary(root,destData);
    el = root.createNewChildElement("ReverbBypass");
    el->addTextElement(String(UserParams[ReverbBypass]));
    copyXmlToBinary(root,destData);
    el = root.createNewChildElement("CompressorBypass");
    el->addTextElement(String(UserParams[CompressorBypass]));
    copyXmlToBinary(root,destData);




    






    
}

void StereoWidthCtrl2AudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    XmlElement* pRoot = getXmlFromBinary(data,sizeInBytes);
    if(pRoot!=NULL)
    {
        forEachXmlChildElement((*pRoot),pChild)
        {
            if(pChild->hasTagName("Bypass"))
            {String text = pChild->getAllSubText();
                setParameter(StereoBypass,text.getFloatValue());}
            else if(pChild->hasTagName("StereoWidth"))
            {String text = pChild->getAllSubText();
                setParameter(StereoWidth,text.getFloatValue());}
            else if(pChild->hasTagName("RoomSize"))
            {String text = pChild->getAllSubText();
                setParameter(Roomsize,text.getFloatValue());}
            else if(pChild->hasTagName("Damping"))
            {String text = pChild->getAllSubText();
                setParameter(Damping,text.getFloatValue());}
            else if(pChild->hasTagName("Wetlevel"))
            {String text = pChild->getAllSubText();
                setParameter(Wetlevel,text.getFloatValue());}
            else if(pChild->hasTagName("Drylevel"))
            {String text = pChild->getAllSubText();
                setParameter(Drylevel,text.getFloatValue());}
            else if(pChild->hasTagName("ReverbWidth"))
            {String text = pChild->getAllSubText();
                setParameter(Reverbwidth,text.getFloatValue());}
            else if(pChild->hasTagName("FreezeMode"))
            {String text = pChild->getAllSubText();
                setParameter(Freezemode,text.getFloatValue());}
            else if(pChild->hasTagName("Threshold"))
            {String text = pChild->getAllSubText();
                setParameter(threshold,text.getFloatValue());}
            else if(pChild->hasTagName("Ratio"))
            {String text = pChild->getAllSubText();
                setParameter(ratio,text.getFloatValue());}
            else if(pChild->hasTagName("ReverbBypass"))
            {String text = pChild->getAllSubText();
                setParameter(ReverbBypass,text.getFloatValue());}
            else if(pChild->hasTagName("CompressorBypass"))
            {String text = pChild->getAllSubText();
                setParameter(CompressorBypass,text.getFloatValue());}
        }
        
        delete pRoot;
        UIUpdateFlag=true;//Request UI update
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new StereoWidthCtrl2AudioProcessor();
}
